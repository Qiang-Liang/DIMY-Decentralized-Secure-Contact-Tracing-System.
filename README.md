# DIMY - 去中心化安全接触追踪系统

DIMY 是一个为呼吸系统传染疾病设计的去中心化、注重隐私保护的安全接触追踪概念验证项目。系统的核心目标是在不牺牲用户隐私的前提下，高效、准确地追踪潜在的病毒接触者。

该项目由Shukun Chen , Yuchen Bai , 和 Mengyu You 合作完成。

## ✨ 项目特点

*   **隐私保护为核心**: 系统通过多种加密和匿名化技术保护用户身份和位置信息。
*   **去中心化接触记录**: 用户间的接触通过点对点（P2P）通信直接记录，无需中央服务器持续追踪。
*   **高效的接触查询**: 使用布隆过滤器（Bloom Filter）进行数据摘要，在保护隐私的同时实现了高效的服务端查询。
*   **安全鲁棒性**: 采用密钥交换和秘密共享技术，增强了系统的安全性和抗攻击能力。
*   **可配置参数**: 系统的关键参数（如ID更新频率）可以灵活配置，以适应不同场景。
*   **安全漏洞分析**: 项目包含了攻击脚本，用于演示和分析系统可能面临的潜在威胁。

## 🛠️ 技术架构

DIMY 系统主要由三个部分组成：用户节点客户端 (`Dimy.py`)、中心服务器 (`DimyServer.py`) 和一个用于安全分析的攻击者模拟器 (`Attacker.py`)。

### 核心技术栈

*   **Python**: 作为主要开发语言。
*   **密码学库 (`cryptography`)**: 用于实现 Diffie-Hellman 密钥交换。
*   **UDP Multicast**: 用于在本地网络中进行设备发现和信息广播。
*   **Shamir 秘密共享**: 将用户的临时ID分割成多个部分，只有集齐足够数量的分享才能还原，增加了窃听难度。
*   **布隆过滤器 (Bloom Filter)**: 用于生成接触记录的数据摘要，既保护了隐私又减小了传输数据量。
*   **Diffie-Hellman (DH) 密钥交换**: 用于在两个接触的设备间安全地生成共享密钥，并据此创建接触事件ID。

### 工作流程

1.  **临时ID生成 (EphID)**
    *   每个用户设备（节点）会定期（例如每15秒）生成一个短暂、随机的 **临时ID (EphID)**。
    *   为防止被直接追踪，EphID 不会直接广播。系统使用 **Shamir秘密共享算法** 将其分解为 `n` 个部分（shares）。

2.  **接触广播与发现**
    *   设备通过 **UDP Multicast** 在本地网络中广播自己的 EphID 分享。
    *   同时，设备会监听其他设备广播的分享。

3.  **接触确认与加密**
    *   当一个设备从另一个设备那里收集到足够数量（`k`个）的分享后，它可以还原出对方完整的 EphID，从而确认一次“接触”。
    *   接触双方使用 **Diffie-Hellman密钥交换** 算法，安全地生成一个共享密钥，并用此密钥派生出一个独一无二的 **接触ID (EncID)**。

4.  **本地存储**
    *   所有生成的 `EncID` 被添加到一个本地的 **天级布隆过滤器 (DBF)** 中。这个过滤器是一种紧凑的数据结构，可以快速检查某个元素是否存在，但不会暴露具体内容。
    *   系统会保存过去几天的DBF。

5.  **接触查询**
    *   设备会定期将本地存储的多个DBF合并成一个 **查询布隆过滤器 (QBF)**，并将其发送到中心服务器。
    *   服务器将接收到的 QBF 与其存储的所有确诊者的接触布隆过滤器 (CBF) 进行比对。
    *   如果匹配度超过阈值，服务器会向用户发送警报，提示可能存在接触风险。

6.  **确诊上报**
    *   当用户被确诊后，他们可以选择将自己本地存储的所有DBF合并成一个 **接触布隆过滤器 (CBF)** 并上传到服务器。
    *   服务器将这个CBF存储到数据库中，用于后续其他用户的查询。


## 🚀 如何运行

### 环境要求

*   Python 3.x
*   第三方库: `cryptography`, `numpy`, `mmh3`, `bitarray`

您可以通过 pip 安装所有依赖：
```bash
pip install cryptography numpy mmh3 bitarray
```

### 1. 启动服务器

首先，在一个终端中启动 `DimyServer.py`。您可以指定一个端口，如果未指定，默认为 `55000`。

```bash
python DimyServer.py [端口号]
# 示例:
python DimyServer.py 55000
```
服务器启动后会开始监听客户端连接。

### 2. 启动用户节点

您可以启动一个或多个用户节点 (`Dimy.py`) 来模拟用户。每个节点都需要在单独的终端中运行。

**启动参数:**
`python Dimy.py [t] [k] [n] [服务器IP] [服务器端口]`

*   `t`: EphID 的生成周期（秒），可选值为 `15, 18, 21, 24, 27, 30`。
*   `k`: 还原一个秘密（EphID）所需要的最少分享数。
*   `n`: 一个秘密（EphID）被分割成的总分享数。
*   `服务器IP`: `DimyServer` 运行的IP地址。
*   `服务器端口`: `DimyServer` 运行的端口。

**示例:**
```bash
# 启动第一个用户节点
python Dimy.py 15 3 5 127.0.0.1 55000

# 在另一个终端启动第二个用户节点
python Dimy.py 15 3 5 127.0.0.1 55000
```
节点启动后，它们会自动开始生成EphID、广播并监听分享。当它们互相确认接触后，会计算并存储EncID。代码中也模拟了用户被确诊并上传CBF的流程。

### 3. (可选) 运行攻击者脚本

为了演示系统的潜在漏洞，您可以运行 `Attacker.py`。攻击者会监听网络中的EphID分享，并尝试重构它们，然后向服务器上传一个恶意的CBF，旨在制造“假阳性”警报。

```bash
python Attacker.py [服务器IP] [服务器端口]
# 示例:
python Attacker.py 127.0.0.1 55000
```

## 🛡️ 安全分析

本项目通过 `Attacker.py` 脚本演示了一种 **“假阳性报告攻击” (False Positive Report Attack)**。

*   **攻击原理**:
    1.  攻击者作为网络中的一个恶意节点，被动地监听和收集其他正常用户广播的 EphID 分享。
    2.  当收集到足够多的分享后，攻击者可以重构出一些无辜用户的完整 EphID。
    3.  攻击者将这些窃听来的 EphID（或基于它们伪造的 EncID）添加到一个伪造的接触布隆过滤器（CBF）中。
    4.  最后，攻击者向服务器上传这个伪造的 CBF，谎称自己已被确诊。

*   **攻击后果**:
    *   当那些被窃取了 EphID 的无辜用户向服务器查询时，他们的 QBF 会与攻击者伪造的 CBF 产生匹配。
    *   这将导致系统向这些无辜用户发送错误的接触警报，引起不必要的恐慌，并可能降低用户对整个系统的信任度。

这个攻击演示了即使在采用了多种隐私保护技术后，协议设计中仍可能存在被利用的漏洞，强调了在安全接触追踪系统中进行持续、深入的安全分析的重要性。



